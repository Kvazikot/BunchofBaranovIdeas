## Как с помощью математики построить лист?

### Математическая суть 

Один из типов фракталов которые я хочу описать в этой статье называется — Системы Итерированных Функций (СИФ). Математические аспекты были разработаны Д. Хатчинсоном, а сам метод стал известен благодаря М. Барнсли. 

В рандомизированном алгоритме который часто называют игрой в «Хаос» в качестве начального множества выбирают одну точку.

X0 = начальная точка (произвольная)
X1 = T1(x0) или T2(x0) или T3(x0)
…
Xn = T1(xn-1) или T2(xn-1) или T3(xn-1)

На каждом шаге получается только одна точка, получаемая путем применения одного из трех аффинных преобразований T1 или T2 или T3.

Таким образом системой итерированных функций называется совокупность введенных выше отображений вместе с итерационной схемой.

На каждом шаге рандомизированного алгоритма испольуется только одна точка и одно случайно выбранное преобразование. Эта точка сразу же выводится на экран, следовательно отпадает необходимость хранить все точки.

В следующем блоке кода определены преобразования нужные для того чтобы построить папоротник, лист и кристалл.

Далее идет реализация описанного выше алгоритма на языке c++, с использованием фреймворка Qt . Ниже я прокоментирую как этот код работает.

`void cif_algo(QPainter* painter, float C[][6], int kMax, int level, int w, int h)`
`{`
    `float P[4]={0,0,0,0.00};`
    `float x,y,x0,y0;`
    `float a,b,c,d; `
    `int kHist[4]={0,0,0,0};`
    `calc_weights(C,P,kMax);`
    `fit_rects = new GeneRectFit(P);`
    `a = 0; b = 0;`
    `c = w; d = h;`
    `int k;`
    `x0 = 1.1; y0 = 1.1;`
    `for(int i=0; i < 100; i++ )`
    `{`
        `k = monte_carlo_method(P, kMax);//PICK(P, kMax);`
        `if(k==-1) continue;`
        `x = (C[k][0] * x0 + C[k][1]*y0 + C[k][4]);`
        `y = (C[k][2] * x0 + C[k][3]*y0 + C[k][5]);`
        `x0 = x;`
        `y0 = y;`
    `}`
    `//qDebug("n1=%d P=%f",n1,(float)n1/1000);`
    `totalIterations = 0;`
    `for(int i=0; i < level; i++)`
    `{`
        `k = monte_carlo_method(P, kMax);`
        `if(k==-1) continue;`
        `totalIterations++;`
        `kHist[k]++;`
        `x = (C[k][0] * x0 + C[k][1]*y0 + C[k][4]);`
        `y = (C[k][2] * x0 + C[k][3]*y0 + C[k][5]);`
        `int xs = a * x + c * x;`
        `int ys = b * x + d * y;`
        `painter->drawPoint(QPoint(xs,ys));`
        `x0 = x;`
        `y0 = y;`
    `}`
    `for(int i=0; i<4; i++)`
        `qDebug("kHist[k]=%f",(float)kHist[i]/totalIterations);`
    `qDebug("totalIterations=%d", totalIterations);`
`}`


Важно отметить что для того чтобы получить картинку без артефактов в виде множества случайных белых точек разбросанных по картинке нужно определить что такое дискретное распределение. В стандартную библиотеку си++ входит дискретное распределение std::discrete_distribution.  Но я решил реализовать это распределение моим способом. Он получился немного громоздким, но тем не менее по скорости работы не намного  уступает встроенному в STL реализацию. Но здесь важно то что мне пришлось углубиться в теорию оптимизации и изучить что такое генетические алгоритмы.

     #   Дискретное распределение. Математическая суть.

Определение: В теории вероятностей случайная величина имеет дискретное равномерное распределение, если она принимает конечное число значений с равными вероятностями, соответственно, вероятность каждого значения равна 

При подбрасывании монеты случайная величина принимает значение , если выпал «орёл», или, если выпала «решка». Вероятность выпадения одного из двух значений равна 1/2, одинакова для обоих значений, поэтому случайная величина имеет дискретное равномерное распределение.
 При бросании игральной кости случайная величина— число точек на грани принимает одно из 6-и возможных значений: . Вероятность выпадения одной точки из шести равна 1/6, одинакова для каждой точки, поэтому случайная величина имеет дискретное равномерное распределение.

      ##  Реализация дискретного распределения методом Монте-Карло. 

Нахождение точек дискретного распределения с заданными вероятностями можно отнести к поиску разбиения прямоугольника на n прямоугольников, площади которых относятся как заданные вероятности. После чего нужно выбрать случайные вещественные x и y в диапазоне попадающем под площадь большого прямоугольника и проверить принадлежность выбранной точки одному из малых прямоугольников.
![](https://user-images.githubusercontent.com/72801945/100219053-95000000-2f26-11eb-831a-0ee60c8aa12a.png)
Рис 1. Разбиение прямоугольника на 4 части

`int monte_carlo_method(float P[],int n)`

`{`

   `float X, Y;`
   `bool hit = false;`
   `//while( !hit && --iterations > 0 )`
   `{`
       `X = (float)rand()/RAND_MAX;`
       `Y = (float)rand()/RAND_MAX;`
       `std::vector<QRectF>::iterator irc;`
       `int cnt=0;`
       `for(irc=fit_rects->scaled_squares.begin(); irc!=fit_rects->scaled_squares.end(); irc++, cnt++)`
       `{`
           `if( X > (*irc).left() && X < (*irc).right())`
            `if( Y <  (*irc).bottom() && Y >  (*irc).top())`
            `{`
                  `hit = true;`
                  `return cnt;`
           `}`
      `}`
      `return -1;`
   `}`
`}`


Поскольку вероятности могут задаваться любыми вещественными числами, нужно найти какой-то метод оптимизации позволяющий найти коэффициенты a,b,c,m. Можно использовать решатели уравнений, но я решил воспользоваться методом много параметрической оптимизации — генетическим алгоритмом. Я рекомендую использовать 
специальные библиотеки для си++ или пайтон, например numpy. Преимущество использования,  numpy.optimize.minimize в том что можно попробовать разные методы оптимизации, меняя только параметры одной этой функции.   
Поиск нужного разбиения с помощью генетического алгоритма.

Согласно Википедии генети́ческий алгори́тм (англ. genetic algorithm)  — это эвристический алгоритм поиска, используемый для решения задач оптимизации и моделирования путём случайного подбора, комбинирования и вариации искомых параметров с использованием механизмов, аналогичных естественному отбору в природе. Является разновидностью эволюционных вычислений, с помощью которых решаются оптимизационные задачи с использованием методов естественной эволюции, таких как наследование, мутации, отбор и кроссинговер. Отличительной особенностью генетического алгоритма является акцент на использование оператора «скрещивания», который производит операцию рекомбинации решений-кандидатов, роль которой аналогична роли скрещивания в живой природе.

Следующий код я написал основываясь на материалах Хабр и algolist.manual.ru. .   
[fit_rects.cpp](https://github.com/Kvazikot/fractali/blob/master/fit_rects.cpp)

## Скриншоты
![fractals222](https://user-images.githubusercontent.com/72801945/100220132-f70d3500-2f27-11eb-96e4-c4c57cc3828d.png)
![4343](https://user-images.githubusercontent.com/72801945/100220145-fc6a7f80-2f27-11eb-85f3-1b5518e587e4.png)
![555](https://user-images.githubusercontent.com/72801945/100220156-00969d00-2f28-11eb-9939-fb6266e56b49.png)
![l-system](https://user-images.githubusercontent.com/72801945/100220329-3fc4ee00-2f28-11eb-987f-a717b24e7d1c.png)
![l-system2](https://user-images.githubusercontent.com/72801945/100220473-7b5fb800-2f28-11eb-8aaf-e41b8161ce2a.png)
![ca2](https://user-images.githubusercontent.com/72801945/100220655-b82baf00-2f28-11eb-8db5-4e0147b88cff.png)

## Литература:

* Божокин С.В., Паршин Д.А. - Фракталы и мультифракталы.djvu 
* Кроновер Р.М. - Фракталы и хаос в динамических системах.djvu} 
* Мандельброт Б.Б. - Фракталы и хаос - 2009.djvu 
* Пайтген Х.-О., Рихтер П.Х - Красота фракталов. Образы комплексных динамических 
* Шредер М. - Фракталы, хаос, степенные законы.djvu 
